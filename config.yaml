version: '0.0.0'
SciViz:
  auth: False
  component_interface:
    static_variables:
      s3_host: $CUSTOM_S3_HOST|s3.amazonaws.com
      s3_region: $CUSTOM_S3_REGION|us-east-1
      s3_access_key: $CUSTOM_S3_ACCESS_KEY|access_key
      s3_secret_key: $CUSTOM_S3_SECRET_KEY|secret_key
      s3_bucket: $CUSTOM_S3_BUCKET|bucket_name
    override: |
      from pharus.component_interface import (type_map, PlotPlotlyStoredjsonComponent,
                                              FileImageAttachComponent, NumpyEncoder)
      import minio
      import io
      from flask import send_file

      class DepthPeth(PlotPlotlyStoredjsonComponent):
          def dj_query_route(self):
              fetch_metadata = self.fetch_metadata
              record = (fetch_metadata['query'] & self.restriction).fetch(limit=1,
                  *fetch_metadata['fetch_args'])
              s3_client = minio.Minio(endpoint=self.static_variables['s3_host'],
                                          region=self.static_variables['s3_region'],
                                          access_key=self.static_variables['s3_access_key'],
                                          secret_key=self.static_variables['s3_secret_key'],
                                          secure=True)
              peth_template = record[0][11]
              color_scale = record[0][10]
              z_range = record[0][9]
              plot_xlim = record[0][8]
              plot_ylim = record[0][7]
              link = record[0][6]
              compiled_link = s3_client.presigned_get_object(self.static_variables['s3_bucket'], link)
              event = record[0][3]
              
              peth_template['data'][0]['x'] = [plot_xlim[0]-0.2, plot_xlim[0]-0.1]
              peth_template['data'][0]['y'] = [plot_ylim[0]-0.2]
              peth_template['data'][0]['z'] = z_range
              peth_template['data'][0]['colorscale'] = color_scale
              peth_template['layout']['images'][0]['source'] = compiled_link
              peth_template['layout']['images'][0]['sizex'] = plot_xlim[1] - plot_xlim[0]
              peth_template['layout']['images'][0]['sizey'] = plot_ylim[1] - plot_ylim[0]
              peth_template['layout']['images'][0]['x'] = plot_xlim[0]
              peth_template['layout']['images'][0]['y'] = plot_ylim[1]
              peth_template['layout']['xaxis']['range'] = plot_xlim
              peth_template['layout']['yaxis']['range'] = plot_ylim
              peth_template['layout']['title']['text'] = f"Depth PETH, aligned to {event} time"
              return NumpyEncoder.dumps(peth_template)

      class TrialDepthRaster(PlotPlotlyStoredjsonComponent):
          def dj_query_route(self):
              fetch_metadata = self.fetch_metadata
              record = (fetch_metadata['query'] & self.restriction).fetch(limit=1,
                  *fetch_metadata['fetch_args'])
              s3_client = minio.Minio(endpoint=self.static_variables['s3_host'],
                                          region=self.static_variables['s3_region'],
                                          access_key=self.static_variables['s3_access_key'],
                                          secret_key=self.static_variables['s3_secret_key'],
                                          secure=True)
              
              tdr_template = record[0][15]
              trial_contrast = record[0][13]
              trial_feedback = record[0][12]
              trial_movement = record[0][11]
              trial_stim_off = record[0][10]
              trial_stim_on = record[0][9]
              plot_title = record[0][8]
              plot_xlim = record[0][7]
              plot_ylim = record[0][6]
              link = record[0][5]
              compiled_link = s3_client.presigned_get_object(self.static_variables['s3_bucket'], link)
              tdr_template['data'][0]['x'] = plot_xlim
              tdr_template['data'][0]['y'] = plot_ylim
              tdr_template['data'][1]['x'] = [trial_stim_on, trial_stim_on]
              tdr_template['data'][1]['y'] = plot_ylim
              tdr_template['data'][2]['x'] = [trial_movement, trial_movement]
              tdr_template['data'][2]['y'] = plot_ylim
              tdr_template['data'][3]['x'] = [trial_feedback, trial_feedback]
              tdr_template['data'][3]['y'] = plot_ylim
              tdr_template['data'][4]['x'] = [trial_stim_off, trial_stim_off]
              tdr_template['data'][4]['y'] = plot_ylim
              tdr_template['layout']['xaxis']['range'] = plot_xlim
              tdr_template['layout']['yaxis']['range'] = plot_ylim
              tdr_template['layout']['title']['text'] = plot_title
              tdr_template['layout']['images'][0]['source'] = compiled_link
              tdr_template['layout']['images'][0]['sizex'] = plot_xlim[1] - plot_xlim[0]
              tdr_template['layout']['images'][0]['sizey'] = plot_ylim[1] - plot_ylim[0]
              tdr_template['layout']['images'][0]['x'] = plot_xlim[0]
              tdr_template['layout']['images'][0]['y'] = plot_ylim[1]
              return NumpyEncoder.dumps(tdr_template)

      class PlotPlotlyRemoveFirst(PlotPlotlyStoredjsonComponent):
          def dj_query_route(self):
              fetch_metadata = self.fetch_metadata
              plotly_json = (fetch_metadata['query'] & self.restriction).fetch1(
                  *fetch_metadata['fetch_args'])
              plotly_json['data'] = [plotly_json['data'][1]]
              return plotly_json

      class FileImageS3GlobalPointerComponent(FileImageAttachComponent):
          def dj_query_route(self):
              fetch_metadata = self.fetch_metadata
              s3_relpath = (fetch_metadata['query'] & self.restriction).fetch1(
                  *fetch_metadata['fetch_args'])
              s3_client = minio.Minio(endpoint=self.static_variables['s3_host'],
                                      region=self.static_variables['s3_region'],
                                      access_key=self.static_variables['s3_access_key'],
                                      secret_key=self.static_variables['s3_secret_key'],
                                      secure=True)
              result = s3_client.get_object(bucket_name=self.static_variables['s3_bucket'],
                                            object_name=s3_relpath)
              # extension in 'download_name' is used to determine the type of image
              return send_file(io.BytesIO(result.data), download_name=s3_relpath)
      
      type_map = dict({'plot:plotly:remove_first': PlotPlotlyRemoveFirst,
                       'file:image:s3:global_pointer': FileImageS3GlobalPointerComponent,
                       'plot:DepthPeth': DepthPeth,
                       'plot:TrialDepthRaster': TrialDepthRaster},
                      **type_map)
  pages:
    Home:
      route: /home
      grids:
        grid1:
          type: fixed
          columns: 1
          row_height: 1500
          components:
            landing description:
              x: 0
              y: 0
              height: 1
              width: 1
              type: markdown
              text: |
                # DataJointâ„¢ powered visualization that adapts to *your* workflows

                ![](https://images.squarespace-cdn.com/content/v1/60e5a50c0632d17c36f6b2d3/1638463454411-SMVPVS9EBPLU9T9T5YMN/unsplash-image-Pyut03Gn98w.jpg?format=1000w)

                ## Features

                - Visualization that can **keep up with changing needs** of your lab
                - Standardized YAML build specification providing a **Low-Code web application
                  design** experience
                - Transport-optimization by leveraging **client-side rendering** with
                  [React](https://reactjs.org/)
                - **Python+[DataJoint](https://www.datajoint.org/) interoperability** to allow
                  streamlined integration
                - Clear separation between business logic from product features i.e. **customization
                  through configuration**
                - **Backend-optimized** page rendering built for big-data and scale
                - Comprehensive permission and security design enabling **flexible access control**
                  modes
                - Securely **manage sensitive information** by configuring it separtely and referencing it in LC spec
                - Pain-free deployments by supporting **live-reload** on changes to configuration
                - Shared, immutable **global variables** available to all components

                ## Component Library Types
                - `markdown`: Often it is necessary to document or describe views via Markdown
                - `page`:
                  - Unique tabbed pages to separate areas within your single-page application
                  - Hidden pages accessible through linking from records in table components
                - `grid`: Layout structure for organizing subcomponents (as seen in
                  [Grafana, AWS Console](https://github.com/react-grid-layout/react-grid-layout#projects-using-react-grid-layout))
                  - `fixed`: For when you know exactly how many components you'd like to render
                  - `dynamic`: Component templating mode when you need to render realtime views that
                    vary in number of components
                - `table`: Sometimes there's nothing better than a table view
                  - paging
                  - sorting
                  - filtering
                  - font/backgrond highlighting
                - `metadata`: Great for showing context info for particular views
                - `plot`: Let's face it, we are going to need to be able to plot stuff
                  - plotly
                - `image`: When you need to render an image file's data directly within the grid
                  - `*.apng`
                  - `*.avif`
                  - `*.gif`
                  - `*.jpeg`
                  - `*.png`
                  - `*.svg`
                  - `*.webp`
                - `custom`: Adding new, custom components is easy with our extensibility hook. See our currently supported components [here](https://github.com/datajoint/pharus/blob/master/pharus/component_interface.py) which you can reference when creating your own.

                ## Acknowledgements

                We'd like to thank [internationalbrainlab.org](https://data.internationalbrainlab.org) for releasing
                publicly various sets of experimental workflow data. In order to provide a DEMO that
                seems more *relevant* we've used this public data to help grasp some of the concepts
                of what is currently supported in SciViz.
    Sessions:
      route: /sessions
      grids:
        grid1:
          type: fixed
          columns: 1
          row_height: 340
          components:
            session table description:
              x: 0
              y: 0
              height: 1
              width: 1
              type: markdown
              text: |
                ## Description

                Below is a summary of experimental session data from an acquisition system. The data
                set is certainly not in the realm of *big data* but there is sufficient records here
                to demonstrate the **backend-optimized** paging, sorting, and filtering. This is
                currently pointed to a live system so please feel free to try out the features and
                interact with the data.

                We've also configured font and background highlighting with the following rules:
                - Color the font in **RED** for the sessions where the subject is deceased.
                - Color the background in **YELLOW** if the session was started later than
                  `2020-09-01`.

                These rules along with configuring the backend query is entirely configurable
                using the standard spec file and DataJoint.

                Also, feel free to *click* below on a specific row of interest to be taken to the
                single-session, hidden page. Go ahead and checkout the session after applying the
                following filter:
                - `session_start_time='2020-09-21 19:02:17'`
                - `subject_uuid='70bf8cbd-d312-4654-a4ea-3a21ea2f541b'`
            Sessions:
              route: /sessions_query
              x: 0
              y: 1
              height: 4
              width: 1
              type: table
              link: /session
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_subject, ibl_acquisition):
                    subj = ibl_subject.Subject().aggr(
                        ibl_subject.Death().proj('death_date') * dj.U('death_date'),
                        death_date='IFNULL(death_date, NULL)',
                        keep_all_rows=True)
                    q = (ibl_acquisition.Session * subj).proj(
                        ...,
                        _sciviz_font='IF(death_date IS NOT NULL, "rgb(255, 0, 0)", NULL)', # deceased mice
                        _sciviz_background='IF(session_start_time > "2020-09-01", "rgba(255, 255, 50, 0.16)", NULL)', # recent sessions
                        )
                    return dict(query=q, fetch_args=[])
    Session:
      hidden: true
      route: /session
      grids:
        grid1:
          type: fixed
          columns: 2
          row_height: 150
          components:
            page description:
              x: 0
              y: 0
              height: 1
              width: 2
              type: markdown
              text: |
                ## Page Description

                This is a hidden session page providing metadata and plotting details for an
                individual session with a subject's spinning brain model. Restrictions are
                provided based on the primary key passed in as query parameters to the page's
                URL.
            session meta:
              route: /session_metadata1_query
              x: 0
              y: 1
              height: 1
              width: 1
              type: metadata
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_subject, ibl_acquisition):
                    subj = ibl_subject.Subject().aggr(
                        ibl_subject.Death().proj('death_date') * dj.U('death_date'),
                        death_date='IFNULL(death_date, NULL)',
                        keep_all_rows=True)
                    q = (ibl_acquisition.Session * subj).proj('session_lab', 'task_protocol')
                    return dict(query=q, fetch_args=[])
            session meta description:
              x: 1
              y: 1
              height: 1
              width: 1
              type: markdown
              text: |
                ## Metadata Description

                This represents specific attributes of this session that we'd like to highlight
                as metadata.
            session reaction time:
              route: /session_plot_query
              x: 0
              y: 2
              height: 3
              width: 1
              type: plot:plotly:stored_json
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    return dict(query=ibl_plotting_behavior.SessionReactionTimeTrialNumber, fetch_args=['plotting_data'])
            session reaction time description:
              x: 1
              y: 2
              height: 3
              width: 1
              type: markdown
              text: |
                ## Stored Plot Description

                Here we are looking to plot this session's reaction time over trial number. However,
                the source for this plot needs some manipulation which is perfect for the **custom
                component** feature.

                What is actually stored in DataJoint is a Plotly JSON with 2 series depicted on the
                left. The **gray** being the raw data and the **black** being its rolled data.
            session custom reaction time:
              route: /session_custom_plot_query
              x: 0
              y: 5
              height: 3
              width: 1
              type: plot:plotly:remove_first
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    return dict(query=ibl_plotting_behavior.SessionReactionTimeTrialNumber, fetch_args=['plotting_data'])
            session custom reaction time description:
              x: 1
              y: 5
              height: 3
              width: 1
              type: markdown
              text: |
                ## Manipulated Plot Description

                It is fairly straightforward to achieve this manipulation by using the **custom
                component** feature.

                Within our specification in `SciViz.component_interface.override`, we can simply define
                a new component like so and utilize it here.

                ```python
                from pharus.component_interface import type_map, PlotPlotlyStoredjsonComponent

                class PlotPlotlyRemoveFirst(PlotPlotlyStoredjsonComponent):
                    def dj_query_route(self):
                        fetch_metadata = self.fetch_metadata
                        plotly_json = (fetch_metadata['query'] & self.restriction).fetch1(
                            *fetch_metadata['fetch_args'])
                        plotly_json['data'] = [plotly_json['data'][1]]
                        return plotly_json

                type_map = dict({'plot:plotly:remove_first': PlotPlotlyRemoveFirst}, **type_map)
                ```
            subject spinning brain:
              route: /session_gif_query
              x: 0
              y: 8
              height: 5
              width: 1
              type: file:image:s3:global_pointer
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_histology):
                    return dict(query=ibl_plotting_histology.SubjectSpinningBrain,
                                fetch_args=['subject_spinning_brain_link'])
            subject spinning brain description:
              x: 1
              y: 8
              height: 2
              width: 1
              type: markdown
              text: |
                ## Spinning Brain GIF Description

                Here we are interested in displaying the 3D spinning brain for the subject. There
                is a `file:image:attach` component that is an excellent base for this supporting
                various different image formats but it still requires some manipulation.
                
                Primarily we need to modify it as our model is stored as a GIF image in S3. The
                connection details need to be supplied to the spec in a sensitive way and we need
                to be able to determine the object's path in S3 via a DataJoint query.

                After configuring the sensitive info properly and the DataJoint query in the spec,
                we can define the following **custom component** to get the job done right.

                ```python
                from pharus.component_interface import type_map, FileImageAttachComponent
                import minio
                import io
                from flask import send_file

                class FileImageS3GlobalPointerComponent(FileImageAttachComponent):
                    def dj_query_route(self):
                        fetch_metadata = self.fetch_metadata
                        s3_relpath = (fetch_metadata['query'] & self.restriction).fetch1(
                            *fetch_metadata['fetch_args'])
                        s3_client = minio.Minio(endpoint=self.static_variables['s3_host'],
                                                region=self.static_variables['s3_region'],
                                                access_key=self.static_variables['s3_access_key'],
                                                secret_key=self.static_variables['s3_secret_key'],
                                                secure=True)
                        result = s3_client.get_object(bucket_name=self.static_variables['s3_bucket'],
                                                      object_name=s3_relpath)
                        # extension in 'download_name' is used to determine the type of image
                        return send_file(io.BytesIO(result.data), download_name=s3_relpath)
                
                type_map = dict({'file:image:s3:global_pointer': FileImageS3GlobalPointerComponent},
                                **type_map)
                ```
        newgrid:
          type: fixed
          columns: 3
          row_height: 80
          components:
            mybuttons:
              x: 0
              y: 0
              height: 1
              width: 1
              type: radiobuttons
              channel: mybuttons
              content:
                feedback: 'event=feedback'
                movement: 'event=movement'
                stim on: 'event=stim on'
            depthPETH:
              x: 0
              y: 1
              height: 6
              width: 1
              type: plot:DepthPeth
              channels: [mybuttons]
              route: /depthpeth
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_ephys):
                    q = ibl_plotting_ephys.DepthPeth * ibl_plotting_ephys.DepthPethTemplate
                    return dict(query=q, fetch_args=[])
            TrialDepthRaster:
              route: /TrialDepthRaster
              x: 1
              y: 1
              height: 10
              width: 2
              type: plot:TrialDepthRaster
              channels: [rasterslider, sliderbuttons]
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_ephys):
                    q = ibl_plotting_ephys.DepthRasterExampleTrial * ibl_plotting_ephys.DepthRasterTemplate
                    return dict(query=q, fetch_args=[])
            rasterslider:
              x: 1
              y: 0
              height: 1
              width: 1
              route: /rasterslider
              type: slider
              channels: [sliderbuttons]
              channel: rasterslider
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_ephys):
                    q = ibl_plotting_ephys.DepthRasterExampleTrial
                    return dict(query=q, fetch_args=['subject_uuid', 'session_start_time', 'probe_idx', 'trial_id', 'trial_contrast'])
            sliderbuttons:
              x: 2
              y: 0
              height: 1
              width: 1
              type: dropdown-static
              channel: sliderbuttons
              content:
                '-1': 'trial_contrast=-1'
                '-0.25': 'trial_contrast=-0.25'
                '-0.125': 'trial_contrast=-0.125'
                '-0.0625': 'trial_contrast=-0.0625'
                '0.0625': 'trial_contrast=0.0625'
                '0.125': 'trial_contrast=0.125'
                '0.25': 'trial_contrast=0.25'
                '1': 'trial_contrast=1'
    Psychometric Curves:
      route: /psychometric_curves
      grids:
        grid1:
          type: fixed
          columns: 1
          row_height: 150
          components:
            session table description:
              x: 0
              y: 0
              height: 1
              width: 1
              type: markdown
              text: |
                ## Description

                Let's suppose that you need a view to be more responsive to changing, realtime
                events. For instance, you'd like to see Psychometric curves for all newer
                sessions from 2 weeks ago (currently pinned to `2020-09-11`). This satisfies
                this by including both the metadata and the Psychometric curve for a given
                recent session.
        grid2:
          route: /psychometric_curves_restrictions
          type: dynamic
          columns: 2
          row_height: 500
          restriction: >
            def restriction(**kwargs):
                return dj.AndList([dict(**kwargs), "session_start_time > '2020-09-18'"])
          dj_query: >
            def dj_query(ibl_plotting_behavior):
                return dict(query=ibl_plotting_behavior.SessionPsychCurve.proj(), fetch_args=[])
          component_templates:
            Metadata:
              route: /psychometric_curves_metadata
              type: metadata
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    q = ibl_plotting_behavior.SessionPsychCurve.proj(
                        ...,
                        '-plotting_data',
                        '-fit_pars',
                        )
                    return dict(query=q, fetch_args=[])
            Psychometric Plot:
              route: /psychometric_curves_plot
              type: plot:plotly:stored_json
              restriction: >
                def restriction(**kwargs):
                    return dict(**kwargs)
              dj_query: >
                def dj_query(ibl_plotting_behavior):
                    return dict(query=ibl_plotting_behavior.SessionPsychCurve(), fetch_args=['plotting_data'])